"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var graphql_1 = require("./types/graphql");
var _ = require("lodash");
var pluralize = require('pluralize');
var upperCamelCase = require('uppercamelcase');
var SDLInferrer = /** @class */ (function () {
    function SDLInferrer() {
    }
    SDLInferrer.prototype.infer = function (dbTables) {
        var _this = this;
        var typeCandidates = dbTables.filter(function (t) { return !t.isJoinTable(); });
        var joinTables = dbTables.filter(function (t) { return t.isJoinTable(); });
        // Assemble basic types
        var types = typeCandidates.map(function (tc) {
            var name = _this.capitalizeFirstLetter(tc.name);
            var directives = ["@pgTable(name: \"" + tc.name + "\")"];
            var fields = tc.columns.map(function (column) {
                var directives = __spread((column.isUnique ? ["@unique"] : []), (column.isPrimaryKey && column.name !== 'id' ? ["@pgColumn(name: \"" + column.name + "\")"] : []), (column.defaultValue && column.defaultValue.trim() !== '[AUTO INCREMENT]'
                    ? __spread((_this.isStringableValue(column)
                        ? ["@default(value: \"" + column.defaultValue + "\")"]
                        : ["@default(value: " + column.defaultValue + ")"])) : []));
                return new graphql_1.GQLField(column.isPrimaryKey ? 'id' : column.name, column.typeIdentifier, !column.nullable, directives, column.isPrimaryKey, column.comment ? column.comment : "", column.typeIdentifier ? false : true);
            });
            var inlineRelations = tc.relations.filter(function (relation) {
                return relation.source_table === tc.name;
            });
            var inlineRelationFields = inlineRelations.map(function (relation) {
                var ambiguousRelations = tc.relations.filter(function (innerRelation) { return innerRelation.source_table === relation.source_table && innerRelation.target_table === relation.target_table; });
                var remoteColumns = _.intersectionWith(tc.columns, ambiguousRelations, function (a, b) { return a.name === b.source_column; });
                var selfAmbiguousRelations = ambiguousRelations.filter(function (relation) { return relation.source_table === relation.target_table; });
                var selfRemoteColumns = _.intersectionWith(tc.columns, selfAmbiguousRelations, function (a, b) { return a.name === b.source_column; });
                var relationName = pluralize(relation.source_table) + '_' + pluralize(_this.removeIdSuffix(relation.source_column));
                var directives = __spread([
                    "@pgRelation(column: \"" + relation.source_column + "\")"
                ], (ambiguousRelations.length > 1 && remoteColumns && remoteColumns.length > 0 ? ["@relation(name: \"" + upperCamelCase(relationName) + "\")"] : []), (selfAmbiguousRelations.length > 0 && selfRemoteColumns && selfRemoteColumns.length > 0 ? ["@relation(name: \"" + upperCamelCase(relationName) + "\")"] : []));
                return new graphql_1.GQLField(_this.removeIdSuffix(relation.source_column), "" + _this.capitalizeFirstLetter(relation.target_table), false, directives, false, "", // TODO: Figure out comment thing for this
                false);
            });
            var relations = tc.relations.filter(function (relation) {
                return relation.target_table === tc.name;
            });
            var relationFields = relations.map(function (relation) {
                var ambiguousRelations = tc.relations.filter(function (innerRelation) { return innerRelation.source_table === relation.source_table && innerRelation.target_table === relation.target_table; });
                var fieldName = ambiguousRelations.length > 1
                    ? pluralize(relation.source_table) + '_' + pluralize(_this.removeIdSuffix(relation.source_column))
                    : pluralize(relation.source_table);
                var selfAmbiguousRelations = ambiguousRelations.filter(function (relation) { return relation.source_table === relation.target_table; });
                var directives = __spread((ambiguousRelations.length > 1 ? ["@relation(name: \"" + upperCamelCase(fieldName) + "\")"] : []), (selfAmbiguousRelations.length > 0 ? ["@relation(name: \"" + upperCamelCase(fieldName) + "\")"] : []));
                return new graphql_1.GQLField(fieldName, "[" + _this.capitalizeFirstLetter(relation.source_table) + "!]", true, directives, false, "", // TODO: Figure out comment thing for this
                false);
            });
            var relationTables = joinTables.reduce(function (relations, joinTable) {
                if (joinTable.relations.some(function (relation) { return relation.target_table === tc.name; })) {
                    return relations.concat(joinTable.relations.filter(function (relation) { return relation.target_table !== tc.name; }));
                }
                else {
                    return relations;
                }
            }, []);
            var relationTableFields = relationTables.map(function (relation) {
                var directives = [
                    "@pgRelationTable(table: \"" + relation.source_table + "\" name: \"" + relation.source_table + "\")"
                ];
                return new graphql_1.GQLField(pluralize(relation.target_table), "[" + _this.capitalizeFirstLetter(relation.target_table) + "!]", true, directives, false, "", // TODO: Figure out comment thing for this
                false);
            });
            var allFields = __spread((_.differenceWith(fields, inlineRelationFields, function (a, b) {
                return _this.removeIdSuffix(a.name) === _this.removeIdSuffix(b.name);
            })), inlineRelationFields, (_.differenceWith(relationFields, relationTableFields, function (a, b) {
                // TODO: Manage this ugly hack if finding relation field in 
                // directive of relation table field 
                // there is also plural to singular hack in this
                return b.directives.join('').indexOf(pluralize.singular(a.name)) > -1;
            })), relationTableFields);
            var someValidFields = fields.some(function (field) { return field.isValid(); });
            return new graphql_1.GQLType(name, allFields, directives, !someValidFields);
        });
        return new graphql_1.SDL(types);
    };
    SDLInferrer.prototype.capitalizeFirstLetter = function (string) {
        return string.charAt(0).toUpperCase() + string.slice(1);
    };
    SDLInferrer.prototype.lowerCaseFirstLetter = function (string) {
        return string.charAt(0).toLowerCase() + string.slice(1);
    };
    SDLInferrer.prototype.removeIdSuffix = function (string) {
        function removeSuffix(suffix, string) {
            if (string.endsWith(suffix)) {
                return string.substring(0, string.length - suffix.length);
            }
            else {
                return string;
            }
        }
        return removeSuffix('_ID', removeSuffix('_id', removeSuffix('Id', string)));
    };
    SDLInferrer.prototype.isStringableValue = function (column) {
        if (column.typeIdentifier == 'String' ||
            column.typeIdentifier == 'DateTime' ||
            column.typeIdentifier == 'Json') {
            return true;
        }
        else {
            return false;
        }
    };
    return SDLInferrer;
}());
exports.SDLInferrer = SDLInferrer;
//# sourceMappingURL=SDLInferrer.js.map
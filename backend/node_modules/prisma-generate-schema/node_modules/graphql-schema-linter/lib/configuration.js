'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Configuration = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _fs = require('fs');

var _graphqlConfig = require('graphql-config');

var _graphqlConfig2 = _interopRequireDefault(_graphqlConfig);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _glob = require('glob');

var _index = require('./rules/index.js');

var _index2 = _interopRequireDefault(_index);

var _source_map = require('./source_map.js');

var _json_formatter = require('./formatters/json_formatter.js');

var _json_formatter2 = _interopRequireDefault(_json_formatter);

var _text_formatter = require('./formatters/text_formatter.js');

var _text_formatter2 = _interopRequireDefault(_text_formatter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var cosmiconfig = require('cosmiconfig');

var Configuration = exports.Configuration = function () {
  /*
    options:
      - configDirectory: path to begin searching for config files
      - format: (required) `text` | `json`
      - rules: [string array] whitelist rules
      - schemaPaths: [string array] file(s) to read schema from
      - stdin: [boolean] pass schema via stdin?
  */
  function Configuration() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var stdinFd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    _classCallCheck(this, Configuration);

    var defaultOptions = { format: 'text' };
    var configOptions = loadOptionsFromConfig(options.configDirectory);

    // TODO Get configs from .graphqlconfig file

    this.options = Object.assign({}, defaultOptions, configOptions, options);
    this.stdinFd = stdinFd;
    this.schema = null;
    this.sourceMap = null;
  }

  _createClass(Configuration, [{
    key: 'getSchema',
    value: function getSchema() {
      if (this.schema) {
        return this.schema;
      }

      var schema;

      if (this.options.stdin) {
        this.schema = getSchemaFromFileDescriptor(this.stdinFd);
        this.sourceMap = new _source_map.SourceMap({ stdin: this.schema });
      } else if (this.options.schemaPaths) {
        var paths = this.options.schemaPaths.map(function (path) {
          if ((0, _glob.hasMagic)(path)) {
            return (0, _glob.sync)(path);
          } else {
            return path;
          }
        }).reduce(function (a, b) {
          return a.concat(b);
        }, [])
        // Resolve paths to absolute paths so that including the same file
        // multiple times is not treated as different files
        .map(function (p) {
          return _path2.default.resolve(p);
        });

        var segments = getSchemaSegmentsFromFiles(paths);

        this.sourceMap = new _source_map.SourceMap(segments);
        this.schema = this.sourceMap.getCombinedSource();
      }

      return this.schema;
    }
  }, {
    key: 'getSchemaSourceMap',
    value: function getSchemaSourceMap() {
      if (!this.sourceMap) {
        this.getSchema();
      }

      return this.sourceMap;
    }
  }, {
    key: 'getFormatter',
    value: function getFormatter() {
      switch (this.options.format) {
        case 'json':
          return _json_formatter2.default;
        case 'text':
          return _text_formatter2.default;
      }
    }
  }, {
    key: 'getRules',
    value: function getRules() {
      var rules = _index2.default;
      var specifiedRules;

      if (this.options.rules && this.options.rules.length > 0) {
        specifiedRules = this.options.rules.map(toUpperCamelCase);
        rules = rules.filter(function (rule) {
          return specifiedRules.indexOf(rule.name) >= 0;
        });
      }

      // DEPRECATED - This code should be removed in v1.0.0.
      if (this.options.only && this.options.only.length > 0) {
        specifiedRules = this.options.only.map(toUpperCamelCase);
        rules = _index2.default.filter(function (rule) {
          return specifiedRules.indexOf(rule.name) >= 0;
        });
      }

      // DEPRECATED - This code should be removed in v1.0.0.
      if (this.options.except && this.options.except.length > 0) {
        specifiedRules = this.options.except.map(toUpperCamelCase);
        rules = _index2.default.filter(function (rule) {
          return specifiedRules.indexOf(rule.name) == -1;
        });
      }

      return rules;
    }
  }, {
    key: 'validate',
    value: function validate() {
      var issues = [];

      var defaultRuleNames = _index2.default.map(function (rule) {
        return rule.name;
      });
      var misConfiguredRuleNames = [].concat(this.options.only || [], this.options.except || [], this.options.rules || []).map(toUpperCamelCase).filter(function (name) {
        return defaultRuleNames.indexOf(name) == -1;
      });

      if (this.getFormatter() == null) {
        issues.push({
          message: 'The output format \'' + this.options.format + '\' is invalid',
          field: 'format',
          type: 'error'
        });
      }

      if (misConfiguredRuleNames.length > 0) {
        issues.push({
          message: 'The following rule(s) are invalid: ' + misConfiguredRuleNames.join(', '),
          field: 'rules',
          type: 'warning'
        });
      }

      return issues;
    }
  }]);

  return Configuration;
}();

function loadOptionsFromConfig(configDirectory) {
  var searchPath = configDirectory || './';

  var cosmic = cosmiconfig('graphql-schema-linter', {
    cache: false,
    sync: true
  }).load(searchPath);

  if (cosmic) {
    return {
      rules: cosmic.config.rules
    };
  } else {
    return {};
  }
}

function getSchemaFromFileDescriptor(fd) {
  var b = new Buffer(1024);
  var data = '';

  while (true) {
    var n = (0, _fs.readSync)(fd, b, 0, b.length);
    if (!n) {
      break;
    }
    data += b.toString('utf8', 0, n);
  }

  return data;
}

function getSchemaFromFile(path) {
  return (0, _fs.readFileSync)(path).toString('utf8');
}

function getSchemaSegmentsFromFiles(paths) {
  return paths.reduce(function (segments, path) {
    segments[path] = getSchemaFromFile(path);
    return segments;
  }, {});
}

function toUpperCamelCase(string) {
  return string.split('-').map(function (part) {
    return part[0].toUpperCase() + part.slice(1);
  }).join('');
}
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var model_1 = require("./model");
var graphql_1 = require("graphql");
var isUniqueDirectiveKey = 'unique';
var defaultValueDirectiveKey = 'default';
var relationDirectiveKey = 'relation';
/**
 * Parses a datamodel given as DSL
 * to an internal representation, convenient for
 * working with.
 */
var DatamodelParser = /** @class */ (function () {
    function DatamodelParser() {
    }
    /**
     * Shorthand to parse the datamodel, given an SDL string.
     * @param schemaString The datamodel as SDL string.
     * @returns A list of types found in the datamodel.
     */
    DatamodelParser.parseFromSchemaString = function (schemaString) {
        var schema = graphql_1.parse(schemaString);
        return DatamodelParser.parseFromSchema(schema);
    };
    /**
     * Parses the datamodel from a graphql-js schema.
     * @param schema The graphql-js schema, representing the datamodel.
     * @returns A list of types found in the datamodel.
     */
    DatamodelParser.parseFromSchema = function (schema) {
        var objectTypes = [];
        // Parse all object types. 
        for (var _i = 0, _a = schema.definitions; _i < _a.length; _i++) {
            var type = _a[_i];
            if (type.kind === 'ObjectTypeDefinition') {
                // For each object type, parse each field.
                var fields = [];
                for (var _b = 0, _c = type.fields; _b < _c.length; _b++) {
                    var field = _c[_b];
                    if (field.kind === 'FieldDefinition') {
                        // Check for type, kind, name and directives. 
                        var name_1 = field.name.value;
                        var kind = DatamodelParser.parseKind(field.type, null);
                        var fieldType = DatamodelParser.parseType(field.type);
                        var isUnique = field.directives.filter(function (x) { return x.name.value === isUniqueDirectiveKey; }).length > 0;
                        var defaultValueDirective = field.directives.filter(function (x) { return x.name.value === defaultValueDirectiveKey; });
                        var defaultValue = defaultValueDirective.length > 0 ? defaultValueDirective[0].arguments[0].value.value : null;
                        var relationDirective = field.directives.filter(function (x) { return x.name.value === relationDirectiveKey; });
                        var relationName = relationDirective.length > 0 ? relationDirective[0].arguments[0].value.value : null;
                        fields.push({
                            name: name_1,
                            type: fieldType,
                            relationName: relationName,
                            defaultValue: defaultValue,
                            isUnique: isUnique,
                            isList: kind === 'ListType',
                            isRequired: kind === 'NonNullType',
                            relatedField: null
                        });
                    }
                }
                objectTypes.push({
                    name: type.name.value,
                    fields: fields,
                    isEnum: false,
                });
            }
        }
        // Parse all enum types
        for (var _d = 0, _e = schema.definitions; _d < _e.length; _d++) {
            var type = _e[_d];
            if (type.kind === 'EnumTypeDefinition') {
                var values = [];
                for (var _f = 0, _g = type.values; _f < _g.length; _f++) {
                    var value = _g[_f];
                    if (value.kind === 'EnumValueDefinition') {
                        var name_2 = value.name.value;
                        // All props except name are ignored for enum defs. 
                        values.push(new model_1.GQLScalarField(name_2, 'String', false));
                    }
                }
                objectTypes.push({
                    name: type.name.value,
                    fields: values,
                    isEnum: true,
                });
            }
        }
        // Now, find all types that we know, 
        // and assign a proper type object instead
        // of the string. 
        for (var _h = 0, objectTypes_1 = objectTypes; _h < objectTypes_1.length; _h++) {
            var typeA = objectTypes_1[_h];
            for (var _j = 0, _k = typeA.fields; _j < _k.length; _j++) {
                var fieldA = _k[_j];
                for (var _l = 0, objectTypes_2 = objectTypes; _l < objectTypes_2.length; _l++) {
                    var typeB = objectTypes_2[_l];
                    // At this stage, every type is a string
                    if (fieldA.type === typeB.name) {
                        fieldA.type = typeB;
                    }
                }
            }
        }
        // Connect all relations that are named. 
        for (var _m = 0, objectTypes_3 = objectTypes; _m < objectTypes_3.length; _m++) {
            var typeA = objectTypes_3[_m];
            for (var _o = 0, _p = typeA.fields; _o < _p.length; _o++) {
                var fieldA = _p[_o];
                if (typeof (fieldA.type) === 'string') {
                    continue; // Assume scalar
                }
                if (fieldA.relationName !== null && fieldA.relatedField === null) {
                    for (var _q = 0, _r = fieldA.type.fields; _q < _r.length; _q++) {
                        var fieldB = _r[_q];
                        if (fieldB.relationName === fieldA.relationName) {
                            if (fieldB.type !== typeA) {
                                throw new Error('Relation type mismatch.');
                            }
                            fieldA.relatedField = fieldB;
                            fieldB.relatedField = fieldA;
                            break;
                        }
                    }
                    if (fieldA.relatedField === null) {
                        throw new Error("Opposite side of relation directive \"" + fieldA.relationName + "\" found at \"" + typeA.name + "." + fieldA.name + "\" is missing on type \"" + fieldA.type.name + "\"");
                    }
                }
            }
        }
        // Connect  obvious relations which are lacking the relatioName directive. 
        // We explicitely DO NOT ignore fields with a given relationName, in accordance
        // to the prisma implementation. 
        for (var _s = 0, objectTypes_4 = objectTypes; _s < objectTypes_4.length; _s++) {
            var typeA = objectTypes_4[_s];
            searchThroughAFields: for (var _t = 0, _u = typeA.fields; _t < _u.length; _t++) {
                var fieldA = _u[_t];
                if (typeof (fieldA.type) === 'string') {
                    continue; // Assume scalar.
                }
                if (fieldA.relatedField !== null) {
                    continue; // Nothing to do, already connected 
                }
                for (var _v = 0, _w = typeA.fields; _v < _w.length; _v++) {
                    var fieldA2 = _w[_v];
                    if (fieldA2 !== fieldA && fieldA2.type === fieldA.type) {
                        // Skip, A has mode than one fields of this relation type. 
                        continue searchThroughAFields;
                    }
                }
                var relationPairs = [];
                // Look for the opposite field by type. 
                for (var _x = 0, _y = fieldA.type.fields; _x < _y.length; _x++) {
                    var fieldB = _y[_x];
                    if (fieldB.type === typeA) {
                        if (fieldB !== fieldA) { // Don't connect self-referencing fields
                            relationPairs.push({ a: fieldA, b: fieldB });
                        }
                    }
                }
                // Create relation iff we have found a single pair
                if (relationPairs.length === 1) {
                    var _z = relationPairs[0], a = _z.a, b = _z.b;
                    a.relatedField = b;
                    b.relatedField = a;
                }
            }
        }
        // That's it. 
        // We could check our model here, if we wanted to. 
        // Possible checks: 
        // * Check if we still use strings for identifying types for non-scalar types
        // * Check if all double-sided relations are connected correctly
        // * Check for duplicate type names
        // * Check for conflicting relations
        return objectTypes;
    };
    /**
     * Traverses an AST branch and finds the next type.
     * This will skip modifiers like NonNullType or ListType.
     * @param type
     */
    DatamodelParser.parseType = function (type) {
        if (type.type) {
            return DatamodelParser.parseType(type.type);
        }
        else if (type.kind !== 'NamedType') {
            throw new Error();
        }
        return type.name.value;
    };
    /**
     * Traverses an AST branch and returns the modifier
     * of the type: Either ListType or NonNullType.
     * @param type
     * @param acc
     */
    DatamodelParser.parseKind = function (type, acc) {
        if (!acc) {
            acc = type.kind;
        }
        // If we find list, we always take list
        if (type.kind === 'ListType') {
            return type.kind;
        }
        // Non-null has higher prio than nullable
        if (type.kind === 'NonNullType') {
            acc = type.kind;
        }
        // When we reach the end, return whatever we have stored.
        if (type.type) {
            return DatamodelParser.parseKind(type.type, acc);
        }
        else {
            return acc;
        }
    };
    return DatamodelParser;
}());
exports.default = DatamodelParser;
//# sourceMappingURL=parser.js.map